defmodule Membrane.RTC.Engine.Endpoint.WebRTC.SimulcastTeeTest do
  use ExUnit.Case, async: true
  use Bitwise

  import Membrane.Testing.Assertions
  import Membrane.ParentSpec

  require Membrane.Pad

  alias Membrane.{Buffer, Pad, Time}
  alias Membrane.RTC.Engine.Endpoint.WebRTC.SimulcastTee
  alias Membrane.RTC.Engine.Support.TestSource
  alias Membrane.RTC.Engine.Track
  alias Membrane.Testing.{Pipeline, Sink}

  @endpoint_id "endpoint"
  @track_id "track1"
  @layers ["h", "m", "l"]

  # We need to fake the keyframe...
  defmacro fake_keyframe(layer) do
    quote do
      <<0::1, 0::2, 5::5>> <> unquote(layer)
    end
  end

  test "Binary generated by fake_keyframe/1 is considered a keyframe by the Forwarder" do
    payload = fake_keyframe("h")

    assert Membrane.RTP.H264.Utils.is_keyframe(payload)
  end

  describe "KeyframeRequestEvent" do
    test "is sent when switching layers" do
      pipeline = build_pipeline()

      for layer <- Enum.reverse(@layers) do
        # request encoding
        Pipeline.execute_actions(pipeline,
          forward: {:tee, {:select_encoding, {@endpoint_id, layer}}}
        )

        # see if Keyframe request is sent
        assert_sink_event(pipeline, {:source, layer}, %Membrane.KeyframeRequestEvent{})

        # Check if a buffer for a given layer actually arrives
        flush_buffers(pipeline)
        assert_sink_buffer(pipeline, :sink, %Buffer{payload: fake_keyframe(^layer)})
      end

      Pipeline.terminate(pipeline, blocking?: true)
    end

    test "is sent when layer is switched off and then turned back on" do
      pipeline = build_pipeline()
      Pipeline.execute_actions(pipeline, forward: {{:source, "h"}, {:set_active, false}})
      assert_sink_event(pipeline, {:source, "m"}, %Membrane.KeyframeRequestEvent{}, 10_000)

      Pipeline.execute_actions(pipeline, forward: {{:source, "h"}, {:set_active, true}})
      assert_sink_event(pipeline, {:source, "h"}, %Membrane.KeyframeRequestEvent{}, 15_000)

      Pipeline.terminate(pipeline, blocking?: true)
    end
  end

  defp build_pipeline() do
    track =
      Track.new(
        :video,
        @track_id,
        "generated",
        :H264,
        90_000,
        :raw,
        nil,
        id: @track_id,
        simulcast_encodings: @layers
      )

    layers_links =
      for layer <- @layers do
        source = %TestSource{
          interval: Time.milliseconds(50),
          payload: fake_keyframe(layer)
        }

        link({:source, layer}, source)
        |> to({:realtimer, layer}, Membrane.Realtimer)
        |> via_in(Pad.ref(:input, {@track_id, layer}))
        |> to(:tee)
      end

    links = [
      link(:tee, %SimulcastTee{track: track})
      |> via_out(Pad.ref(:output, {:endpoint, @endpoint_id}))
      |> to(:sink, Sink)
      | layers_links
    ]

    {:ok, pipeline} = Pipeline.start_link(links: links)

    assert_pipeline_playback_changed(pipeline, :prepared, :playing)
    assert_start_of_stream(pipeline, :sink)

    Process.sleep(100)

    pipeline
  end

  defp flush_buffers(pipeline) do
    receive do
      {Membrane.Testing.Pipeline, ^pipeline, {:handle_notification, {{:buffer, _buffer}, :sink}}} ->
        flush_buffers(pipeline)
    after
      0 -> :ok
    end
  end
end
